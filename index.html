<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.36.1/min/vs/loader.min.js"></script>
    <!-- Add Prism CSS and JS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #1e1e1e;
            color: #ffffff;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .top-bar {
            background-color: #333333;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #454545;
        }

        .debug-toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #cccccc;
            font-size: 14px;
        }

        .debug-toggle-container input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .debug-output-panel {
            height: 200px;
            background-color: #1e1e1e;
            border-top: 1px solid #454545;
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }

        .debug-output-panel.active {
            display: block;
        }

        .debug-output-header {
            padding: 8px 16px;
            background-color: #252526;
            border-bottom: 1px solid #454545;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .debug-output-content {
            padding: 8px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            color: #cccccc;
            height: calc(100% - 40px);
            overflow-y: auto;
        }

        .debug-message {
            padding: 4px 8px;
            margin: 4px 0;
            border-radius: 4px;
            font-size: 13px;
        }

        .debug-message.error {
            background-color: rgba(244, 67, 54, 0.1);
            border-left: 3px solid #f44336;
        }

        .debug-message.warning {
            background-color: rgba(255, 152, 0, 0.1);
            border-left: 3px solid #ff9800;
        }

        .debug-message.info {
            background-color: rgba(33, 150, 243, 0.1);
            border-left: 3px solid #2196f3;
        }

        .debug-message .line-number {
            color: #858585;
            margin-right: 8px;
        }

        .debug-message .message-content {
            display: inline-block;
        }

        .debug-message .suggestion {
            margin-top: 4px;
            padding: 4px 8px;
            background-color: #2d2d2d;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
        }

        .activity-bar {
            width: 48px;
            background-color: #333333;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 0;
            border-right: 1px solid #454545;
        }

        .activity-bar-icon {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #858585;
            transition: all 0.2s;
        }

        .activity-bar-icon:hover {
            color: #ffffff;
            background-color: #454545;
        }

        .activity-bar-icon.active {
            color: #ffffff;
            background-color: #454545;
            border-left: 2px solid #007acc;
        }

        .activity-bar-icon svg {
            width: 24px;
            height: 24px;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .panels-container {
            display: flex;
            flex-direction: row;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background-color: #252526;
            border-right: 1px solid #454545;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 8px 16px;
            font-size: 14px;
            color: #cccccc;
            border-bottom: 1px solid #454545;
        }

        .file-explorer {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .file-item {
            padding: 4px 8px;
            display: flex;
            align-items: center;
            cursor: pointer;
            color: #cccccc;
            transition: background-color 0.2s;
        }

        .file-item:hover {
            background-color: #2a2d2e;
        }

        .file-item.selected {
            background-color: #37373d;
        }

        .file-item svg {
            width: 16px;
            height: 16px;
            margin-right: 8px;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; /* Prevents flex item from overflowing */
            position: relative;
        }

        .editor-tabs {
            background-color: #252526;
            border-bottom: 1px solid #454545;
            display: flex;
            align-items: center;
            padding: 0 8px;
            height: 35px;
            overflow-x: auto;
        }

        .editor-tab {
            display: flex;
            align-items: center;
            padding: 0 12px;
            height: 35px;
            background-color: #2d2d2d;
            border-right: 1px solid #454545;
            color: #cccccc;
            cursor: pointer;
            user-select: none;
            min-width: 120px;
            max-width: 200px;
        }

        .editor-tab.active {
            background-color: #1e1e1e;
            color: #ffffff;
        }

        .editor-tab .close-button {
            margin-left: 8px;
            opacity: 0.7;
            padding: 2px;
            border-radius: 3px;
        }

        .editor-tab .close-button:hover {
            background-color: #454545;
            opacity: 1;
        }

        #editor {
            flex: 1;
            width: 100%;
        }

        .status-bar {
            background-color: #007acc;
            color: #ffffff;
            padding: 4px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
        }

        .chat-panel {
            width: 300px;
            min-width: 200px;
            max-width: 800px;
            background-color: #252526;
            border-left: 1px solid #454545;
            display: none;
            flex-shrink: 0;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .chat-panel.active {
            display: flex;
        }

        .chat-panel-resizer {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: transparent;
            cursor: ew-resize;
            transition: background-color 0.2s;
        }

        .chat-panel-resizer:hover,
        .chat-panel-resizer.resizing {
            background-color: #007acc;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            height: calc(100% - 100px);
        }

        .chat-message {
            padding: 8px 12px;
            border-radius: 8px;
            max-width: 85%;
            word-wrap: break-word;
            line-height: 1.4;
            font-size: 13px;
            position: relative;
            display: inline-block;
            white-space: pre-wrap;
        }

        .chat-message.user {
            background-color: #0e639c;
            margin-left: auto;
            color: white;
            border-top-right-radius: 2px;
        }

        .chat-message.assistant {
            background-color: #2d2d2d;
            margin-right: auto;
            color: #cccccc;
            border-top-left-radius: 2px;
        }

        .chat-message.loading {
            background-color: #2d2d2d;
            color: #858585;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chat-message.loading::after {
            content: '';
            width: 12px;
            height: 12px;
            border: 2px solid #858585;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .chat-message::before {
            content: '';
            position: absolute;
            top: 0;
            width: 8px;
            height: 8px;
            background: inherit;
        }

        .chat-message.user::before {
            right: -4px;
            transform: rotate(45deg);
        }

        .chat-message.assistant::before {
            left: -4px;
            transform: rotate(45deg);
        }

        .chat-input {
            padding: 12px 16px;
            border-top: 1px solid #454545;
            background-color: #252526;
            position: sticky;
            bottom: 0;
            z-index: 1;
        }

        .chat-input input {
            width: 100%;
            padding: 8px 12px;
            background-color: #3c3c3c;
            border: 1px solid #454545;
            color: #ffffff;
            border-radius: 4px;
            font-size: 13px;
            box-sizing: border-box;
        }

        .chat-input input:focus {
            outline: none;
            border-color: #007acc;
        }

        .chat-input input::placeholder {
            color: #858585;
        }

        .terminal-panel {
            height: 300px;
            background-color: #1e1e1e;
            border-top: 1px solid #454545;
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
        }

        .terminal-panel.active {
            display: block;
        }

        .terminal-header {
            padding: 8px 16px;
            background-color: #252526;
            border-bottom: 1px solid #454545;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .terminal-content {
            padding: 8px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            color: #cccccc;
            height: calc(100% - 40px);
            overflow-y: auto;
        }

        .terminal-input {
            display: flex;
            align-items: center;
            padding: 4px 8px;
        }

        .terminal-prompt {
            color: #0d9373;
            margin-right: 8px;
        }

        .terminal-input input {
            flex: 1;
            background: none;
            border: none;
            color: #cccccc;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            outline: none;
        }

        /* Code block styles */
        .chat-message pre {
            background-color: #1e1e1e;
            border-radius: 4px;
            padding: 12px;
            margin: 8px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        .chat-message code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            color: #d4d4d4;
        }

        /* Syntax highlighting colors */
        .chat-message .language-javascript,
        .chat-message .language-js,
        .chat-message .language-html,
        .chat-message .language-css,
        .chat-message .language-json,
        .chat-message .language-python,
        .chat-message .language-java,
        .chat-message .language-cpp,
        .chat-message .language-c,
        .chat-message .language-cs,
        .chat-message .language-go,
        .chat-message .language-rs,
        .chat-message .language-rb,
        .chat-message .language-php {
            color: #d4d4d4;
        }

        .chat-message .keyword { color: #569cd6; }
        .chat-message .string { color: #ce9178; }
        .chat-message .comment { color: #6a9955; }
        .chat-message .function { color: #dcdcaa; }
        .chat-message .number { color: #b5cea8; }
        .chat-message .operator { color: #d4d4d4; }
        .chat-message .class { color: #4ec9b0; }
        .chat-message .variable { color: #9cdcfe; }

        .review-panel {
            width: 400px;
            min-width: 300px;
            max-width: 1000px;
            background-color: #252526;
            border-left: 1px solid #454545;
            display: none;
            flex-shrink: 0;
            height: 100%;
            position: relative;
            flex-direction: column;
        }

        .review-panel.active {
            display: flex;
        }

        .review-panel-resizer {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: transparent;
            cursor: ew-resize;
            transition: background-color 0.2s;
        }

        .review-panel-resizer:hover,
        .review-panel-resizer.resizing {
            background-color: #007acc;
        }

        .review-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background-color: #252526;
            border-bottom: 1px solid #454545;
        }

        .review-panel-header h2 {
            margin: 0;
            font-size: 18px;
            color: #ffffff;
            font-weight: 600;
        }

        .review-panel-collapse {
            background: none;
            border: none;
            color: #cccccc;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .review-panel-collapse:hover {
            color: #ffffff;
        }

        .review-dashboard {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .review-card {
            background-color: #2d2d2d;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .review-card:hover {
            transform: translateY(-2px);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .card-header h3 {
            margin: 0;
            color: #ffffff;
            font-size: 18px;
            font-weight: 600;
        }

        .score {
            background-color: #4caf50;
            color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .score::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.8);
        }

        .score.warning {
            background-color: #ff9800;
        }

        .score.error {
            background-color: #f44336;
        }

        .metric {
            margin-bottom: 20px;
            background-color: #333333;
            padding: 16px;
            border-radius: 8px;
        }

        .metric-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .metric-label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ffffff;
            font-size: 14px;
            font-weight: 500;
        }

        .metric-value {
            color: #007acc;
            font-weight: bold;
            font-size: 16px;
        }

        .progress-bar {
            height: 8px;
            background-color: #454545;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress {
            height: 100%;
            background: linear-gradient(90deg, #007acc, #00b3e6);
            border-radius: 4px;
            transition: width 0.5s ease;
        }

        .metric-explanation {
            font-size: 13px;
            color: #999999;
            margin-top: 8px;
            line-height: 1.4;
        }

        .issue-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .issue-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background-color: #333333;
            border-radius: 8px;
            border-left: 4px solid transparent;
            transition: background-color 0.2s ease;
        }

        .issue-item:hover {
            background-color: #3c3c3c;
        }

        .issue-item.high {
            border-left-color: #f44336;
        }

        .issue-item.medium {
            border-left-color: #ff9800;
        }

        .issue-item.low {
            border-left-color: #4caf50;
        }

        .issue-severity {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .issue-content {
            flex: 1;
        }

        .issue-title {
            color: #ffffff;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .issue-description {
            color: #999999;
            font-size: 13px;
            line-height: 1.4;
        }

        .insight-item, .suggestion-item {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 16px;
            background-color: #333333;
            border-radius: 8px;
            margin-bottom: 12px;
            transition: transform 0.2s ease;
        }

        .insight-item:hover, .suggestion-item:hover {
            transform: translateX(4px);
        }

        .insight-icon, .suggestion-icon {
            font-size: 24px;
            background-color: #2d2d2d;
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .insight-text, .suggestion-text {
            flex: 1;
        }

        .insight-text h4, .suggestion-text h4 {
            margin: 0 0 8px 0;
            color: #ffffff;
            font-size: 16px;
            font-weight: 500;
        }

        .insight-text p, .suggestion-text p {
            margin: 0;
            color: #999999;
            font-size: 14px;
            line-height: 1.5;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #cccccc;
        }

        .error-message {
            color: #f44336;
            padding: 16px;
            text-align: center;
            background-color: #2d2d2d;
            border-radius: 8px;
        }

        /* Add new styles for highlighted lines */
        .highlighted-code-line {
            background-color: rgba(0, 122, 204, 0.2) !important;
            border-left: 3px solid #007acc !important;
        }

        .issue-item, .metric, .insight-item, .suggestion-item {
            cursor: pointer;
        }

        .issue-item:hover, .metric:hover, .insight-item:hover, .suggestion-item:hover {
            outline: 1px solid #007acc;
        }

        .issue-location, .insight-location, .suggestion-location {
            font-size: 12px;
            color: #007acc;
            margin-top: 4px;
        }

        .issue-item:hover .issue-location,
        .insight-item:hover .insight-location,
        .suggestion-item:hover .suggestion-location {
            text-decoration: underline;
        }

        /* Add debug panel styles */
        .debug-panel {
            width: 400px;
            min-width: 300px;
            max-width: 1000px;
            background-color: #252526;
            border-left: 1px solid #454545;
            display: none;
            flex-shrink: 0;
            height: 100%;
            position: relative;
            flex-direction: column;
        }

        .debug-panel.active {
            display: flex;
        }

        .debug-panel-resizer {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 4px;
            background-color: transparent;
            cursor: ew-resize;
            transition: background-color 0.2s;
        }

        .debug-panel-resizer:hover,
        .debug-panel-resizer.resizing {
            background-color: #007acc;
        }

        .debug-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background-color: #252526;
            border-bottom: 1px solid #454545;
        }

        .debug-panel-header h2 {
            margin: 0;
            font-size: 18px;
            color: #ffffff;
            font-weight: 600;
        }

        .debug-panel-collapse {
            background: none;
            border: none;
            color: #cccccc;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .debug-panel-collapse:hover {
            color: #ffffff;
        }

        .debug-dashboard {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .debug-card {
            background-color: #2d2d2d;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
        }

        .debug-card:hover {
            transform: translateY(-2px);
        }

        .bug-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            background-color: #333333;
            border-radius: 8px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .bug-item:hover {
            background-color: #3c3c3c;
        }

        .bug-severity {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
        }

        .bug-severity.critical {
            background-color: #f44336;
            color: white;
        }

        .bug-severity.warning {
            background-color: #ff9800;
            color: white;
        }

        .bug-severity.info {
            background-color: #2196f3;
            color: white;
        }

        .bug-content {
            flex: 1;
        }

        .bug-title {
            color: #ffffff;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .bug-description {
            color: #999999;
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 8px;
        }

        .bug-location {
            font-size: 12px;
            color: #007acc;
        }

        .bug-suggestion {
            background-color: #1e1e1e;
            border-radius: 4px;
            padding: 12px;
            margin-top: 8px;
            font-family: 'Consolas', monospace;
            font-size: 13px;
            color: #d4d4d4;
            overflow-x: auto;
        }

        .bug-suggestion pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .bug-suggestion code {
            color: #d4d4d4;
            font-family: 'Consolas', monospace;
        }

        /* Add new styles for the enhanced debug panel */
        .bug-scenario, .bug-execution-path {
            font-size: 13px;
            color: #ff9800;
            margin: 4px 0;
            padding: 4px 8px;
            background-color: rgba(255, 152, 0, 0.1);
            border-radius: 4px;
        }

        .bug-potential-issues {
            margin: 8px 0;
            padding: 8px;
            background-color: rgba(244, 67, 54, 0.1);
            border-radius: 4px;
        }

        .bug-potential-issues-title {
            color: #f44336;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .bug-potential-issues ul {
            margin: 0;
            padding-left: 20px;
            color: #ff5252;
        }

        .bug-potential-issues li {
            margin: 2px 0;
        }

        .bug-suggestion-title {
            color: #4caf50;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .bug-suggestion {
            margin-top: 12px;
            padding: 12px;
            background-color: #1e1e1e;
            border-radius: 4px;
            border-left: 3px solid #4caf50;
        }

        /* Update code block styles */
        .code-block-container {
            position: relative;
            margin: 1em 0;
            background: #1e1e1e;
            border-radius: 4px;
            overflow: hidden;
        }

        .code-block-container pre {
            margin: 0;
            padding: 1em;
            background: #1e1e1e;
            border-radius: 4px;
            overflow-x: auto;
        }

        .code-block-container code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .copy-button {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 4px 8px;
            background-color: #2d2d2d;
            border: 1px solid #454545;
            border-radius: 4px;
            color: #cccccc;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1;
        }

        .code-block-container:hover .copy-button {
            opacity: 1;
        }

        .copy-button:hover {
            background-color: #3c3c3c;
            color: #ffffff;
        }

        .copy-button.copied {
            background-color: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        /* Prism.js theme customization */
        .token.comment,
        .token.prolog,
        .token.doctype,
        .token.cdata {
            color: #6a9955;
        }

        .token.punctuation {
            color: #d4d4d4;
        }

        .token.property,
        .token.tag,
        .token.boolean,
        .token.number,
        .token.constant,
        .token.symbol {
            color: #b5cea8;
        }

        .token.selector,
        .token.string,
        .token.char,
        .token.builtin {
            color: #ce9178;
        }

        .token.operator,
        .token.entity,
        .token.url,
        .language-css .token.string,
        .style .token.string {
            color: #d4d4d4;
        }

        .token.keyword {
            color: #569cd6;
        }

        .token.function {
            color: #dcdcaa;
        }

        .token.class-name {
            color: #4ec9b0;
        }

        .token.variable {
            color: #9cdcfe;
        }

        /* Add styles for run button */
        .run-button {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .run-button:hover {
            background-color: #45a049;
        }

        .run-button svg {
            width: 16px;
            height: 16px;
        }

        .run-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .run-button.loading {
            background-color: #2196f3;
            cursor: wait;
        }

        .run-button.loading svg {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Terminal message styles */
        .terminal-message {
            padding: 4px 8px;
            margin: 4px 0;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .terminal-message.error {
            color: #ff5252;
        }

        .terminal-message.success {
            color: #4caf50;
        }

        .terminal-message.info {
            color: #2196f3;
        }

        .terminal-timestamp {
            color: #858585;
            margin-right: 8px;
        }

        /* Run button styles */
        .run-button-container {
            display: flex;
            align-items: center;
            margin-left: 10px;
        }

        #run-button {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        #run-button:hover {
            background-color: #45a049;
        }

        #run-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .run-icon {
            font-size: 16px;
        }

        .run-text {
            font-weight: 500;
        }

        /* Playground Panel Styles */
        .playground-panel {
            flex: 1;
            background-color: #252526;
            display: none;
            flex-direction: column;
            min-width: 0;
            position: relative;
        }

        .playground-panel.active {
            display: flex;
        }

        .playground-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background-color: #252526;
            border-bottom: 1px solid #454545;
            height: 35px;
        }

        .playground-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        #playground-language {
            padding: 6px 12px;
            background-color: #3c3c3c;
            border: 1px solid #454545;
            color: #ffffff;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }

        #playground-language:focus {
            outline: none;
            border-color: #007acc;
        }

        #playground-language option {
            background-color: #3c3c3c;
            color: #ffffff;
        }

        #playground-editor {
            flex: 1;
            min-height: 0;
        }

        .playground-terminal {
            height: 200px;
            background-color: #1e1e1e;
            border-top: 1px solid #454545;
        }

        .playground-terminal .terminal-header {
            padding: 8px 16px;
            background-color: #252526;
            border-bottom: 1px solid #454545;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .playground-terminal .terminal-content {
            padding: 8px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            color: #cccccc;
            height: calc(100% - 40px);
            overflow-y: auto;
        }

        /* Add chat panel header styles */
        .chat-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            background-color: #252526;
            border-bottom: 1px solid #454545;
        }

        .chat-panel-header h2 {
            margin: 0;
            font-size: 18px;
            color: #ffffff;
            font-weight: 600;
        }

        .chat-panel-collapse {
            background: none;
            border: none;
            color: #cccccc;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chat-panel-collapse:hover {
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="title">Monaco Editor</div>
        <div class="debug-toggle-container">
            <input type="checkbox" id="debug-toggle" onchange="toggleDebugAssistance()">
            <label for="debug-toggle">Real-time Debugging</label>
            <!-- Run button -->
            <div class="run-button-container">
                <button id="run-button" onclick="runCode()">
                    <span class="run-icon">â–¶</span>
                    <span class="run-text">Run</span>
                </button>
            </div>
        </div>
    </div>
    <div class="main-content">
        <div class="activity-bar">
            <div class="activity-bar-icon active" onclick="togglePanel('explorer')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M3 7v10a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-6l-2-2H5a2 2 0 0 0-2 2z"/>
                </svg>
            </div>
            <div class="activity-bar-icon" onclick="togglePanel('terminal')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M4 17l5-5-5-5M12 19h8"/>
                </svg>
            </div>
            <div class="activity-bar-icon" onclick="togglePanel('chat')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10z"/>
                </svg>
            </div>
            <div class="activity-bar-icon" onclick="togglePanel('review')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 20V10M12 10L8 14M12 10L16 14M2 12C2 6.48 6.48 2 12 2C17.52 2 22 6.48 22 12C22 17.52 17.52 22 12 22C6.48 22 2 17.52 2 12Z"/>
                </svg>
            </div>
            <div class="activity-bar-icon" onclick="togglePanel('debug')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z"/>
                    <path d="M12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16Z"/>
                    <path d="M12 8V4"/>
                    <path d="M12 20V16"/>
                    <path d="M4 12H8"/>
                    <path d="M16 12H20"/>
                </svg>
            </div>
            <div class="activity-bar-icon" onclick="togglePanel('playground')">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M12 2L2 7L12 12L22 7L12 2Z"/>
                    <path d="M2 17L12 22L22 17"/>
                    <path d="M2 12L12 17L22 12"/>
                </svg>
            </div>
        </div>
        <div class="panels-container">
            <div class="sidebar" id="explorer-panel">
                <div class="sidebar-header">EXPLORER</div>
                <div class="file-explorer" id="file-explorer"></div>
            </div>
            <div class="editor-container">
                <div class="editor-tabs" id="editor-tabs"></div>
                <div id="editor"></div>
                <div class="status-bar">
                    <span id="status-text">Ready</span>
                </div>
            </div>
            <div class="chat-panel" id="chat-panel">
                <div class="chat-panel-resizer" id="chat-panel-resizer"></div>
                <div class="chat-panel-header">
                    <h2>CHAT</h2>
                    <button class="chat-panel-collapse" onclick="toggleChatPanel()">Ã—</button>
                </div>
                <div class="chat-messages" id="chat-messages"></div>
                <div class="chat-input">
                    <input type="text" id="chat-input" placeholder="Type a message...">
                </div>
            </div>
            <div class="review-panel" id="review-panel">
                <div class="review-panel-resizer" id="review-panel-resizer"></div>
                <div class="review-panel-header">
                    <h2>CODE REVIEW</h2>
                    <button class="review-panel-collapse" onclick="toggleReviewPanel()">Ã—</button>
                </div>
                <div class="review-dashboard">
                    <div class="review-card code-quality">
                        <div class="card-header">
                            <h3>Code Quality</h3>
                            <div class="score">92%</div>
                        </div>
                        <div class="card-content">
                            <div class="metric">
                                <div class="metric-header">
                                    <div class="metric-label">
                                        <span class="metric-icon">ðŸ”„</span>
                                        Complexity
                                    </div>
                                    <div class="metric-value">75%</div>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress" style="width: 75%"></div>
                                </div>
                                <div class="metric-explanation">Code complexity is well-managed with clear function boundaries</div>
                            </div>
                            <div class="metric">
                                <div class="metric-header">
                                    <div class="metric-label">
                                        <span class="metric-icon">ðŸ”§</span>
                                        Maintainability
                                    </div>
                                    <div class="metric-value">85%</div>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress" style="width: 85%"></div>
                                </div>
                                <div class="metric-explanation">High maintainability score with good code organization</div>
                            </div>
                            <div class="metric">
                                <div class="metric-header">
                                    <div class="metric-label">
                                        <span class="metric-icon">ðŸŽ¯</span>
                                        Test Coverage
                                    </div>
                                    <div class="metric-value">60%</div>
                                </div>
                                <div class="progress-bar">
                                    <div class="progress" style="width: 60%"></div>
                                </div>
                                <div class="metric-explanation">Moderate test coverage, could be improved</div>
                            </div>
                        </div>
                    </div>

                    <div class="review-card issues">
                        <div class="card-header">
                            <h3>Issues</h3>
                            <div class="score warning">3</div>
                        </div>
                        <div class="card-content">
                            <div class="issue-list">
                                <div class="issue-item high">
                                    <div class="issue-content">
                                        <div class="issue-title">Memory Leak Risk</div>
                                        <div class="issue-description">Potential memory leak detected in main event loop</div>
                                    </div>
                                </div>
                                <div class="issue-item medium">
                                    <div class="issue-content">
                                        <div class="issue-title">Unused Variable</div>
                                        <div class="issue-description">Variable declared but never used in function scope</div>
                                    </div>
                                </div>
                                <div class="issue-item low">
                                    <div class="issue-content">
                                        <div class="issue-title">Documentation Gap</div>
                                        <div class="issue-description">Missing documentation for key functions</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="debug-panel" id="debug-panel">
                <div class="debug-panel-resizer" id="debug-panel-resizer"></div>
                <div class="debug-panel-header">
                    <h2>DEBUG ANALYSIS</h2>
                    <button class="debug-panel-collapse" onclick="toggleDebugPanel()">Ã—</button>
                </div>
                <div class="debug-dashboard">
                    <!-- Debug content will be dynamically populated -->
                </div>
            </div>
            <div class="playground-panel" id="playground-panel">
                <div class="playground-panel-resizer" id="playground-panel-resizer"></div>
                <div class="playground-header">
                    <div class="playground-controls">
                        <select id="playground-language" onchange="updatePlaygroundLanguage()">
                            <option value="python">Python</option>
                            <option value="javascript">JavaScript</option>
                            <option value="java">Java</option>
                            <option value="cpp">C++</option>
                            <option value="c">C</option>
                            <option value="go">Go</option>
                            <option value="rust">Rust</option>
                            <option value="ruby">Ruby</option>
                            <option value="php">PHP</option>
                        </select>
                        <button id="playground-run" onclick="runPlaygroundCode()">
                            <span class="run-icon">â–¶</span>
                            <span class="run-text">Run</span>
                        </button>
                    </div>
                    <button class="playground-panel-collapse" onclick="togglePlaygroundPanel()">Ã—</button>
                </div>
                <div id="playground-editor"></div>
                <div class="playground-terminal">
                    <div class="terminal-header">
                        <span>Playground Output</span>
                    </div>
                    <div class="terminal-content" id="playground-output"></div>
                </div>
            </div>
        </div>
    </div>
    <div class="terminal-panel" id="terminal-panel">
        <div class="terminal-header">
            <span>Terminal</span>
            <span class="close-button" onclick="closeTerminalPanel()">Ã—</span>
        </div>
        <div class="terminal-content" id="terminal-content"></div>
        <div class="terminal-input">
            <span class="terminal-prompt">$</span>
            <input type="text" id="terminal-input" placeholder="Enter command...">
        </div>
    </div>
    <div class="debug-output-panel" id="debug-output-panel">
        <div class="debug-output-header">
            <span>Debug Output</span>
            <span class="close-button" onclick="toggleDebugOutput()">Ã—</span>
        </div>
        <div class="debug-output-content" id="debug-output-content"></div>
    </div>

    <script>
        require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.36.1/min/vs' }});
        require(['vs/editor/editor.main'], function() {
            window.editorLoaded = true;
            window.dispatchEvent(new Event('editorLoaded'));
        });

        function togglePanel(panel) {
            // Update activity bar icons
            document.querySelectorAll('.activity-bar-icon').forEach(icon => {
                icon.classList.remove('active');
            });
            event.currentTarget.classList.add('active');

            // Show/hide panels
            const explorerPanel = document.getElementById('explorer-panel');
            const chatPanel = document.getElementById('chat-panel');
            const terminalPanel = document.getElementById('terminal-panel');
            const reviewPanel = document.getElementById('review-panel');
            const debugPanel = document.getElementById('debug-panel');
            const playgroundPanel = document.getElementById('playground-panel');
            const editorContainer = document.querySelector('.editor-container');

            // Handle special cases for chat, debug, and review panels
            if (panel === 'chat' || panel === 'debug' || panel === 'review') {
                // Toggle the specific panel without affecting others
                const targetPanel = document.getElementById(`${panel}-panel`);
                const isOpening = targetPanel.style.display !== 'flex';
                targetPanel.style.display = isOpening ? 'flex' : 'none';
                
                // Keep the playground panel visible if it's active
                if (playgroundPanel.style.display === 'flex') {
                    playgroundPanel.style.display = 'flex';
                } else {
                    // If playground is not active, show the editor container
                    editorContainer.style.display = 'flex';
                }
                
                // Keep the explorer panel visible
                explorerPanel.style.display = 'flex';

                // Trigger analysis when opening panels
                if (isOpening) {
                    if (panel === 'review') {
                        updateReviewDashboard();
                    } else if (panel === 'debug') {
                        updateDebugDashboard();
                    }
                }
                return;
            }

            // Reset all panels for other cases
            explorerPanel.style.display = 'none';
            chatPanel.style.display = 'none';
            terminalPanel.style.display = 'none';
            reviewPanel.style.display = 'none';
            debugPanel.style.display = 'none';
            playgroundPanel.style.display = 'none';
            editorContainer.style.display = 'none';

            // Show the selected panels
            if (panel === 'explorer') {
                explorerPanel.style.display = 'flex';
                editorContainer.style.display = 'flex';
            } else if (panel === 'terminal') {
                explorerPanel.style.display = 'flex';
                editorContainer.style.display = 'flex';
                terminalPanel.style.display = 'block';
            } else if (panel === 'playground') {
                explorerPanel.style.display = 'flex';
                playgroundPanel.style.display = 'flex';
                if (!playgroundEditor) {
                    initializePlayground();
                }
            }
        }

        // Add this new function to handle terminal panel closing
        function closeTerminalPanel() {
            const terminalPanel = document.getElementById('terminal-panel');
            terminalPanel.style.display = 'none';
            // Remove active class from terminal button
            document.querySelector('.activity-bar-icon[onclick="togglePanel(\'terminal\')"]').classList.remove('active');
        }

        function toggleReviewPanel() {
            const reviewPanel = document.getElementById('review-panel');
            reviewPanel.style.display = 'none';
            // Remove active class from review button
            document.querySelector('.activity-bar-icon[onclick="togglePanel(\'review\')"]').classList.remove('active');
        }

        function toggleDebugPanel() {
            const debugPanel = document.getElementById('debug-panel');
            debugPanel.style.display = 'none';
            // Remove active class from debug button
            document.querySelector('.activity-bar-icon[onclick="togglePanel(\'debug\')"]').classList.remove('active');
        }

        async function updateReviewDashboard() {
            const dashboard = document.querySelector('.review-dashboard');
            dashboard.innerHTML = '<div class="loading">Analyzing code...</div>';

            try {
                // Get current file content
                let currentFileContent = '';
                if (window.editor && window.editor.getModel()) {
                    currentFileContent = window.editor.getModel().getValue();
                }

                // Update the prompts to include line information
                const prompts = {
                    quality: `Analyze the code quality and provide metrics. Return ONLY a JSON object in this exact format:
                    {
                        "overallScore": number between 0-100,
                        "metrics": {
                            "Complexity": { "score": number between 0-100, "explanation": "string", "affectedLines": [{"start": number, "end": number}] },
                            "Maintainability": { "score": number between 0-100, "explanation": "string", "affectedLines": [{"start": number, "end": number}] },
                            "Test Coverage": { "score": number between 0-100, "explanation": "string", "affectedLines": [{"start": number, "end": number}] }
                        }
                    }`,

                    issues: `Find potential issues in the code. Return ONLY a JSON array in this exact format:
                    [
                        { 
                            "severity": "high/medium/low", 
                            "description": "string",
                            "title": "string",
                            "lineStart": number,
                            "lineEnd": number
                        }
                    ]`,

                    insights: `Provide overall insights about the codebase. Return ONLY a JSON array in this exact format:
                    [
                        { 
                            "icon": "emoji", 
                            "title": "string", 
                            "description": "string",
                            "affectedLines": [{"start": number, "end": number}]
                        }
                    ]`,

                    optimization: `Suggest code optimizations. Return ONLY a JSON array in this exact format:
                    [
                        { 
                            "icon": "emoji", 
                            "category": "string", 
                            "description": "string",
                            "lineStart": number,
                            "lineEnd": number
                        }
                    ]`
                };

                // Fetch analysis for each aspect
                const responses = await Promise.all(
                    Object.entries(prompts).map(async ([key, prompt]) => {
                        try {
                            const response = await fetch('http://localhost:3000/api/chat', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    message: prompt,
                                    currentFileContent
                                })
                            });

                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }

                            const data = await response.json();
                            
                            // Try to extract JSON from the response
                            let parsedResponse;
                            try {
                                // First try direct parsing
                                parsedResponse = JSON.parse(data.response);
                            } catch (e) {
                                // If direct parsing fails, try to extract JSON from markdown code blocks
                                const jsonMatch = data.response.match(/```(?:json)?\n([\s\S]*?)```/);
                                if (jsonMatch) {
                                    try {
                                        parsedResponse = JSON.parse(jsonMatch[1].trim());
                                    } catch (e2) {
                                        // If still fails, try to extract any JSON-like structure
                                        const jsonStructure = data.response.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                                        if (jsonStructure) {
                                            try {
                                                parsedResponse = JSON.parse(jsonStructure[0]);
                                            } catch (e3) {
                                                throw new Error('Could not parse JSON from response');
                                            }
                                        } else {
                                            throw new Error('No valid JSON found in response');
                                        }
                                    }
                                } else {
                                    // If no code block found, try to extract any JSON-like structure
                                    const jsonStructure = data.response.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                                    if (jsonStructure) {
                                        try {
                                            parsedResponse = JSON.parse(jsonStructure[0]);
                                        } catch (e2) {
                                            throw new Error('Could not parse JSON from response');
                                        }
                                    } else {
                                        throw new Error('No valid JSON found in response');
                                    }
                                }
                            }

                            return [key, parsedResponse];
                        } catch (error) {
                            console.error(`Error processing ${key}:`, error);
                            // Return default values for the specific type
                            return [key, getDefaultValue(key)];
                        }
                    })
                );

                // Update dashboard with responses
                const analysis = Object.fromEntries(responses);
                
                // Update dashboard
                dashboard.innerHTML = '';
                dashboard.appendChild(createQualityCard(analysis.quality));
                dashboard.appendChild(createIssuesCard(analysis.issues));
                dashboard.appendChild(createInsightsCard(analysis.insights));
                dashboard.appendChild(createOptimizationCard(analysis.optimization));

            } catch (error) {
                console.error('Review dashboard error:', error);
                dashboard.innerHTML = `
                    <div class="error-message">
                        Error analyzing code: ${error.message}
                    </div>
                `;
            }
        }

        // Helper function to provide default values when parsing fails
        function getDefaultValue(type) {
            switch (type) {
                case 'quality':
                    return {
                        overallScore: 0,
                        metrics: {
                            "Complexity": { score: 0, explanation: "Unable to analyze" },
                            "Maintainability": { score: 0, explanation: "Unable to analyze" },
                            "Test Coverage": { score: 0, explanation: "Unable to analyze" }
                        }
                    };
                case 'issues':
                    return [{ severity: "medium", description: "Unable to analyze code issues" }];
                case 'insights':
                    return [{ icon: "âš ï¸", title: "Analysis Failed", description: "Unable to generate insights" }];
                case 'optimization':
                    return [{ icon: "âš ï¸", category: "Analysis Failed", description: "Unable to generate optimization suggestions" }];
                default:
                    return null;
            }
        }

        // Add highlighting functionality
        function highlightCodeLines(startLine, endLine) {
            if (!window.editor) return;

            // Remove any existing decorations
            if (window.currentDecorations) {
                window.editor.deltaDecorations(window.currentDecorations, []);
            }

            // Add new decoration
            window.currentDecorations = window.editor.deltaDecorations([], [
                {
                    range: new monaco.Range(startLine, 1, endLine, 1),
                    options: {
                        isWholeLine: true,
                        className: 'highlighted-code-line',
                        inlineClassName: 'highlighted-code-line'
                    }
                }
            ]);

            // Scroll to the highlighted lines
            window.editor.revealLineInCenter(startLine);
        }

        // Update the card creation functions to include click handlers
        function createQualityCard(quality) {
            const card = document.createElement('div');
            card.className = 'review-card code-quality';
            card.innerHTML = `
                <div class="card-header">
                    <h3>Code Quality</h3>
                    <div class="score">${quality.overallScore}%</div>
                </div>
                <div class="card-content">
                    ${Object.entries(quality.metrics).map(([metric, value]) => `
                        <div class="metric" data-lines='${JSON.stringify(value.affectedLines)}'>
                            <div class="metric-header">
                                <div class="metric-label">
                                    <span class="metric-icon">${getMetricIcon(metric)}</span>
                                    ${metric}
                                </div>
                                <div class="metric-value">${value.score}%</div>
                            </div>
                            <div class="progress-bar">
                                <div class="progress" style="width: ${value.score}%"></div>
                            </div>
                            <div class="metric-explanation">${value.explanation}</div>
                        </div>
                    `).join('')}
                </div>
            `;

            // Add click handlers for metrics
            card.querySelectorAll('.metric').forEach(metric => {
                metric.addEventListener('click', () => {
                    const lines = JSON.parse(metric.dataset.lines);
                    if (lines && lines.length > 0) {
                        highlightCodeLines(lines[0].start, lines[0].end);
                    }
                });
            });

            return card;
        }

        function getMetricIcon(metric) {
            const icons = {
                'Complexity': 'ðŸ”„',
                'Maintainability': 'ðŸ”§',
                'Test Coverage': 'ðŸŽ¯'
            };
            return icons[metric] || 'ðŸ“Š';
        }

        function createIssuesCard(issues) {
            const card = document.createElement('div');
            card.className = 'review-card issues';
            card.innerHTML = `
                <div class="card-header">
                    <h3>Issues</h3>
                    <div class="score ${issues.length > 5 ? 'error' : issues.length > 2 ? 'warning' : ''}">${issues.length}</div>
                </div>
                <div class="card-content">
                    <div class="issue-list">
                        ${issues.map(issue => `
                            <div class="issue-item ${issue.severity}" data-start="${issue.lineStart}" data-end="${issue.lineEnd}">
                                <div class="issue-content">
                                    <div class="issue-title">${getIssueTitle(issue)}</div>
                                    <div class="issue-description">${issue.description}</div>
                                    <div class="issue-location">Lines ${issue.lineStart}-${issue.lineEnd}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            // Add click handlers for issues
            card.querySelectorAll('.issue-item').forEach(item => {
                item.addEventListener('click', () => {
                    const start = parseInt(item.dataset.start);
                    const end = parseInt(item.dataset.end);
                    highlightCodeLines(start, end);
                });
            });

            return card;
        }

        function getIssueTitle(issue) {
            const titles = {
                'high': 'Critical Issue',
                'medium': 'Warning',
                'low': 'Suggestion'
            };
            return titles[issue.severity] || 'Issue';
        }

        function createInsightsCard(insights) {
            const card = document.createElement('div');
            card.className = 'review-card insights';
            card.innerHTML = `
                <div class="card-header">
                    <h3>Overall Insights</h3>
                </div>
                <div class="card-content">
                    ${insights.map(insight => `
                        <div class="insight-item" data-lines='${JSON.stringify(insight.affectedLines)}'>
                            <div class="insight-icon">${insight.icon}</div>
                            <div class="insight-text">
                                <h4>${insight.title}</h4>
                                <p>${insight.description}</p>
                                ${insight.affectedLines ? `<div class="insight-location">Lines ${insight.affectedLines[0].start}-${insight.affectedLines[0].end}</div>` : ''}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;

            // Add click handlers for insights
            card.querySelectorAll('.insight-item').forEach(item => {
                item.addEventListener('click', () => {
                    const lines = JSON.parse(item.dataset.lines);
                    if (lines && lines.length > 0) {
                        highlightCodeLines(lines[0].start, lines[0].end);
                    }
                });
            });

            return card;
        }

        function createOptimizationCard(optimizations) {
            const card = document.createElement('div');
            card.className = 'review-card optimization';
            card.innerHTML = `
                <div class="card-header">
                    <h3>Optimization Suggestions</h3>
                </div>
                <div class="card-content">
                    ${optimizations.map(opt => `
                        <div class="suggestion-item" data-start="${opt.lineStart}" data-end="${opt.lineEnd}">
                            <div class="suggestion-icon">${opt.icon}</div>
                            <div class="suggestion-text">
                                <h4>${opt.category}</h4>
                                <p>${opt.description}</p>
                                <div class="suggestion-location">Lines ${opt.lineStart}-${opt.lineEnd}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;

            // Add click handlers for suggestions
            card.querySelectorAll('.suggestion-item').forEach(item => {
                item.addEventListener('click', () => {
                    const start = parseInt(item.dataset.start);
                    const end = parseInt(item.dataset.end);
                    highlightCodeLines(start, end);
                });
            });

            return card;
        }

        // Initialize chat functionality
        const chatInput = document.getElementById('chat-input');
        const chatMessages = document.getElementById('chat-messages');

        chatInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const message = chatInput.value.trim();
                if (message) {
                    // Disable input while processing
                    chatInput.disabled = true;
                    chatInput.value = '';

                    // Add user message
                    addMessage(message, true);

                    // Add loading message
                    const loadingMessage = document.createElement('div');
                    loadingMessage.className = 'chat-message assistant loading';
                    loadingMessage.textContent = 'Thinking';
                    chatMessages.appendChild(loadingMessage);

                    try {
                        // Get current file content if available
                        let currentFileContent = '';
                        
                        // Get the current file content directly from the editor
                        if (window.editor && window.editor.getModel()) {
                            currentFileContent = window.editor.getModel().getValue();
                            console.log('Got file content:', currentFileContent.substring(0, 100) + '...');
                        }

                        const response = await fetch('http://localhost:3000/api/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ 
                                message,
                                currentFileContent
                            })
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.error || 'Failed to get response from server');
                        }

                        const data = await response.json();
                        
                        // Remove loading message
                        loadingMessage.remove();
                        
                        // Add AI response with code formatting
                        addMessage(data.response, false);
                    } catch (error) {
                        console.error('Chat error:', error);
                        // Remove loading message
                        loadingMessage.remove();
                        // Add error message
                        addMessage(`Error: ${error.message || 'Failed to get response. Please try again.'}`, false);
                    } finally {
                        // Re-enable input
                        chatInput.disabled = false;
                        chatInput.focus();
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    }
                }
            }
        });

        // Initialize terminal functionality
        const terminalInput = document.getElementById('terminal-input');
        const terminalContent = document.getElementById('terminal-content');

        terminalInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const command = terminalInput.value.trim();
                if (command) {
                    // Add command to terminal
                    const commandLine = document.createElement('div');
                    commandLine.innerHTML = `<span class="terminal-prompt">$</span> ${command}`;
                    terminalContent.appendChild(commandLine);

                    // Execute command (you can implement this later)
                    const output = document.createElement('div');
                    output.textContent = 'Command executed: ' + command;
                    terminalContent.appendChild(output);

                    terminalInput.value = '';
                    terminalContent.scrollTop = terminalContent.scrollHeight;
                }
            }
        });

        const chatPanelResizer = document.getElementById('chat-panel-resizer');
        const chatPanel = document.getElementById('chat-panel');
        let isResizing = false;
        let startX;
        let startWidth;

        chatPanelResizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            startX = e.clientX;
            startWidth = chatPanel.offsetWidth;
            chatPanelResizer.classList.add('resizing');
            document.body.style.cursor = 'ew-resize';
            e.preventDefault(); // Prevent text selection while resizing
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            
            const width = startWidth - (e.clientX - startX);
            const minWidth = 200;
            const maxWidth = 800;
            
            if (width >= minWidth && width <= maxWidth) {
                chatPanel.style.width = `${width}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            chatPanelResizer.classList.remove('resizing');
            document.body.style.cursor = '';
        });

        // Add touch support for mobile devices
        chatPanelResizer.addEventListener('touchstart', (e) => {
            isResizing = true;
            startX = e.touches[0].clientX;
            startWidth = chatPanel.offsetWidth;
            chatPanelResizer.classList.add('resizing');
            document.body.style.cursor = 'ew-resize';
            e.preventDefault();
        });

        document.addEventListener('touchmove', (e) => {
            if (!isResizing) return;
            
            const width = startWidth - (e.touches[0].clientX - startX);
            const minWidth = 200;
            const maxWidth = 800;
            
            if (width >= minWidth && width <= maxWidth) {
                chatPanel.style.width = `${width}px`;
            }
        });

        document.addEventListener('touchend', () => {
            isResizing = false;
            chatPanelResizer.classList.remove('resizing');
            document.body.style.cursor = '';
        });

        // Add review panel resizer functionality
        const reviewPanelResizer = document.getElementById('review-panel-resizer');
        let isReviewResizing = false;
        let reviewStartX;
        let reviewStartWidth;

        reviewPanelResizer.addEventListener('mousedown', (e) => {
            isReviewResizing = true;
            reviewStartX = e.clientX;
            reviewStartWidth = reviewPanel.offsetWidth;
            reviewPanelResizer.classList.add('resizing');
            document.body.style.cursor = 'ew-resize';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isReviewResizing) return;
            
            const width = reviewStartWidth - (e.clientX - reviewStartX);
            const minWidth = 200;
            const maxWidth = 800;
            
            if (width >= minWidth && width <= maxWidth) {
                reviewPanel.style.width = `${width}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            isReviewResizing = false;
            reviewPanelResizer.classList.remove('resizing');
            document.body.style.cursor = '';
        });

        // Add debug panel resizer functionality
        const debugPanelResizer = document.getElementById('debug-panel-resizer');
        let isDebugResizing = false;
        let debugStartX;
        let debugStartWidth;

        debugPanelResizer.addEventListener('mousedown', (e) => {
            isDebugResizing = true;
            debugStartX = e.clientX;
            debugStartWidth = debugPanel.offsetWidth;
            debugPanelResizer.classList.add('resizing');
            document.body.style.cursor = 'ew-resize';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDebugResizing) return;
            
            const width = debugStartWidth - (e.clientX - debugStartX);
            const minWidth = 300;
            const maxWidth = 1000;
            
            if (width >= minWidth && width <= maxWidth) {
                debugPanel.style.width = `${width}px`;
            }
        });

        document.addEventListener('mouseup', () => {
            isDebugResizing = false;
            debugPanelResizer.classList.remove('resizing');
            document.body.style.cursor = '';
        });

        // Update the main content styles to better handle the layout
        document.querySelector('.main-content').style.display = 'flex';
        document.querySelector('.main-content').style.flexDirection = 'row';
        document.querySelector('.main-content').style.overflow = 'hidden';

        async function updateDebugDashboard() {
            const dashboard = document.querySelector('.debug-dashboard');
            dashboard.innerHTML = '<div class="loading">Analyzing code for execution issues and syntax errors...</div>';

            try {
                // Get current file content and detect language
                let currentFileContent = '';
                let currentLanguage = '';
                if (window.editor && window.editor.getModel()) {
                    currentFileContent = window.editor.getModel().getValue();
                    currentLanguage = window.editor.getModel().getLanguageId();
                }

                // Debug analysis prompts
                const prompts = {
                    syntax: `Analyze this ${currentLanguage} code for syntax errors and compilation issues. Be thorough and nitpicky. Look for:
                    1. Missing or incorrect delimiters (brackets, parentheses, braces)
                    2. Incorrect indentation
                    3. Missing or extra semicolons/colons
                    4. Missing or incorrect keywords
                    5. Incorrect variable declarations
                    6. Incorrect function definitions
                    7. Incorrect class definitions
                    8. Incorrect method definitions
                    9. Incorrect import/require statements
                    10. Incorrect string literals
                    11. Incorrect number literals
                    12. Incorrect operator usage
                    13. Incorrect control flow statements
                    14. Incorrect exception handling
                    15. Incorrect type declarations
                    16. Incorrect array/object syntax
                    17. Incorrect comment syntax
                    18. Incorrect line breaks
                    19. Incorrect whitespace
                    20. Incomplete statements
                    
                    Return ONLY a JSON array in this exact format:
                    [
                        {
                            "severity": "critical/warning/info",
                            "title": "string",
                            "description": "string",
                            "lineStart": number,
                            "lineEnd": number,
                            "suggestion": "string (code block with suggested fix)",
                            "type": "syntax/compilation",
                            "category": "string (specific type of syntax error)",
                            "impact": "string (potential impact of the error)",
                            "prevention": "string (how to prevent this type of error)",
                            "language": "string (programming language)",
                            "commonMistake": "string (why this is a common mistake)",
                            "bestPractice": "string (language-specific best practice)"
                        }
                    ]`,

                    runtime: `Perform a comprehensive ${currentLanguage} runtime error analysis. Look for:
                    1. Null/undefined reference errors
                    2. Type errors
                    3. Value errors
                    4. Index out of bounds errors
                    5. Key not found errors
                    6. Attribute/property errors
                    7. Import/module errors
                    8. Division by zero errors
                    9. File not found errors
                    10. Permission errors
                    11. Memory errors
                    12. Stack overflow errors
                    13. Recursion errors
                    14. Iterator errors
                    15. Generator errors
                    16. Promise/async errors
                    17. Event loop errors
                    18. Resource cleanup errors
                    19. Thread/process errors
                    20. Network errors
                    
                    Return ONLY a JSON array in this exact format:
                    [
                        {
                            "severity": "critical/warning/info",
                            "title": "string",
                            "description": "string",
                            "lineStart": number,
                            "lineEnd": number,
                            "suggestion": "string (code block with suggested fix)",
                            "type": "runtime",
                            "errorType": "string (type of runtime error)",
                            "scenario": "string (when this error might occur)",
                            "impact": "string (potential impact of the error)",
                            "prevention": "string (how to prevent this type of error)",
                            "testing": "string (how to test for this issue)",
                            "relatedIssues": ["string (list of related potential issues)"],
                            "language": "string (programming language)",
                            "commonMistake": "string (why this is a common mistake)"
                        }
                    ]`,

                    execution: `Perform a detailed ${currentLanguage} execution path analysis. Look for:
                    1. Infinite loops
                    2. Dead code
                    3. Unreachable code
                    4. Infinite recursion
                    5. Stack overflow risks
                    6. Performance bottlenecks
                    7. Memory leaks
                    8. Resource leaks
                    9. Thread safety issues
                    10. Concurrency issues
                    11. Event loop blocking
                    12. Async/await issues
                    13. Promise chain issues
                    14. Generator issues
                    15. Context manager issues
                    16. Resource cleanup issues
                    17. Exception propagation issues
                    18. Logging issues
                    19. State management issues
                    20. Input validation issues
                    
                    Return ONLY a JSON array in this exact format:
                    [
                        {
                            "severity": "critical/warning/info",
                            "title": "string",
                            "description": "string",
                            "lineStart": number,
                            "lineEnd": number,
                            "suggestion": "string (code block with suggested fix)",
                            "type": "execution",
                            "executionPath": "string (description of the execution path)",
                            "potentialIssues": ["string (list of potential issues)"],
                            "impact": "string (potential impact of the issue)",
                            "prevention": "string (how to prevent this type of issue)",
                            "testing": "string (how to test for this issue)",
                            "bestPractices": ["string (list of best practices to follow)"],
                            "relatedIssues": ["string (list of related potential issues)"],
                            "language": "string (programming language)",
                            "performanceImpact": "string (performance impact description)"
                        }
                    ]`,

                    security: `Perform a thorough ${currentLanguage} security analysis. Look for:
                    1. SQL injection vulnerabilities
                    2. Command injection risks
                    3. Path traversal vulnerabilities
                    4. File inclusion vulnerabilities
                    5. Input validation issues
                    6. Output encoding issues
                    7. Authentication flaws
                    8. Authorization issues
                    9. Session management problems
                    10. Password handling issues
                    11. Cryptographic weaknesses
                    12. File upload vulnerabilities
                    13. Sensitive data exposure
                    14. Security misconfigurations
                    15. Dependency vulnerabilities
                    16. Code injection risks
                    17. Deserialization vulnerabilities
                    18. XSS vulnerabilities
                    19. CSRF vulnerabilities
                    20. Race conditions
                    
                    Return ONLY a JSON array in this exact format:
                    [
                        {
                            "severity": "critical/warning/info",
                            "title": "string",
                            "description": "string",
                            "lineStart": number,
                            "lineEnd": number,
                            "suggestion": "string (code block with suggested fix)",
                            "type": "security",
                            "vulnerability": "string (type of security vulnerability)",
                            "impact": "string (potential security impact)",
                            "prevention": "string (how to prevent this vulnerability)",
                            "testing": "string (how to test for this vulnerability)",
                            "bestPractices": ["string (list of security best practices)"],
                            "relatedIssues": ["string (list of related security issues)"],
                            "language": "string (programming language)",
                            "commonMistake": "string (why this is a common mistake)",
                            "securityImpact": "string (detailed security impact)"
                        }
                    ]`,

                    performance: `Perform a detailed ${currentLanguage} performance analysis. Look for:
                    1. Algorithmic inefficiencies
                    2. Memory leaks
                    3. CPU bottlenecks
                    4. I/O operations
                    5. Network requests
                    6. Database queries
                    7. Cache usage
                    8. Resource utilization
                    9. Garbage collection issues
                    10. Event loop blocking
                    11. Synchronous operations
                    12. Large data structures
                    13. Unnecessary computations
                    14. Redundant operations
                    15. Poor data structures
                    16. Inefficient loops
                    17. Unnecessary object creation
                    18. Poor string concatenation
                    19. Inefficient array operations
                    20. Poor memory management
                    
                    Return ONLY a JSON array in this exact format:
                    [
                        {
                            "severity": "critical/warning/info",
                            "title": "string",
                            "description": "string",
                            "lineStart": number,
                            "lineEnd": number,
                            "suggestion": "string (code block with suggested fix)",
                            "type": "performance",
                            "bottleneck": "string (type of performance bottleneck)",
                            "impact": "string (performance impact)",
                            "optimization": "string (how to optimize)",
                            "testing": "string (how to measure performance)",
                            "bestPractices": ["string (list of performance best practices)"],
                            "relatedIssues": ["string (list of related performance issues)"],
                            "language": "string (programming language)",
                            "performanceImpact": "string (detailed performance impact)",
                            "optimizationPotential": "string (potential optimization gains)"
                        }
                    ]`
                };

                // Fetch analysis for each aspect
                const responses = await Promise.all(
                    Object.entries(prompts).map(async ([key, prompt]) => {
                        try {
                            const response = await fetch('http://localhost:3000/api/chat', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    message: prompt,
                                    currentFileContent
                                })
                            });

                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }

                            const data = await response.json();
                            
                            // Try to extract JSON from the response
                            let parsedResponse;
                            try {
                                // First try direct parsing
                                parsedResponse = JSON.parse(data.response);
                            } catch (e) {
                                // If direct parsing fails, try to extract JSON from markdown code blocks
                                const jsonMatch = data.response.match(/```(?:json)?\n([\s\S]*?)```/);
                                if (jsonMatch) {
                                    try {
                                        parsedResponse = JSON.parse(jsonMatch[1].trim());
                                    } catch (e2) {
                                        // If still fails, try to extract any JSON-like structure
                                        const jsonStructure = data.response.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                                        if (jsonStructure) {
                                            try {
                                                parsedResponse = JSON.parse(jsonStructure[0]);
                                            } catch (e3) {
                                                throw new Error('Could not parse JSON from response');
                                            }
                                        } else {
                                            throw new Error('No valid JSON found in response');
                                        }
                                    }
                                } else {
                                    // If no code block found, try to extract any JSON-like structure
                                    const jsonStructure = data.response.match(/\{[\s\S]*\}|\[[\s\S]*\]/);
                                    if (jsonStructure) {
                                        try {
                                            parsedResponse = JSON.parse(jsonStructure[0]);
                                        } catch (e2) {
                                            throw new Error('Could not parse JSON from response');
                                        }
                                    } else {
                                        throw new Error('No valid JSON found in response');
                                    }
                                }
                            }

                            return [key, parsedResponse];
                        } catch (error) {
                            console.error(`Error processing ${key}:`, error);
                            // Return default values for the specific type
                            return [key, getDefaultDebugValue(key)];
                        }
                    })
                );

                // Update dashboard with responses
                const analysis = Object.fromEntries(responses);
                
                // Create and append debug cards
                dashboard.innerHTML = '';
                dashboard.appendChild(createBugCard('Syntax & Compilation Issues', analysis.syntax));
                dashboard.appendChild(createBugCard('Runtime Error Analysis', analysis.runtime));
                dashboard.appendChild(createBugCard('Execution Path Analysis', analysis.execution));
                dashboard.appendChild(createBugCard('Security Analysis', analysis.security));
                dashboard.appendChild(createBugCard('Performance Analysis', analysis.performance));

            } catch (error) {
                console.error('Debug dashboard error:', error);
                dashboard.innerHTML = `
                    <div class="error-message">
                        Error analyzing code: ${error.message}
                    </div>
                `;
            }
        }

        // Helper function to provide default values when parsing fails
        function getDefaultDebugValue(type) {
            switch (type) {
                case 'syntax':
                    return [{
                        severity: "warning",
                        title: "Syntax Analysis Failed",
                        description: "Unable to analyze syntax issues",
                        lineStart: 1,
                        lineEnd: 1,
                        suggestion: "Please check your code for syntax errors",
                        type: "syntax/compilation",
                        category: "Analysis Error",
                        impact: "Unable to detect syntax issues",
                        prevention: "Ensure code is properly formatted",
                        language: "All",
                        commonMistake: "Analysis system error",
                        bestPractice: "Check code manually"
                    }];
                case 'runtime':
                    return [{
                        severity: "warning",
                        title: "Runtime Analysis Failed",
                        description: "Unable to analyze runtime issues",
                        lineStart: 1,
                        lineEnd: 1,
                        suggestion: "Please check your code for runtime errors",
                        type: "runtime",
                        errorType: "Analysis Error",
                        scenario: "Analysis system error",
                        impact: "Unable to detect runtime issues",
                        prevention: "Ensure code is properly formatted",
                        testing: "Manual testing required",
                        relatedIssues: ["Analysis system error"],
                        language: "All",
                        commonMistake: "Analysis system error"
                    }];
                case 'execution':
                    return [{
                        severity: "warning",
                        title: "Execution Analysis Failed",
                        description: "Unable to analyze execution paths",
                        lineStart: 1,
                        lineEnd: 1,
                        suggestion: "Please check your code for execution issues",
                        type: "execution",
                        executionPath: "Analysis system error",
                        potentialIssues: ["Unable to analyze execution paths"],
                        impact: "Unable to detect execution issues",
                        prevention: "Ensure code is properly formatted",
                        testing: "Manual testing required",
                        bestPractices: ["Check code manually"],
                        relatedIssues: ["Analysis system error"],
                        language: "All",
                        performanceImpact: "Unable to analyze"
                    }];
                case 'security':
                    return [{
                        severity: "warning",
                        title: "Security Analysis Failed",
                        description: "Unable to analyze security issues",
                        lineStart: 1,
                        lineEnd: 1,
                        suggestion: "Please check your code for security issues",
                        type: "security",
                        vulnerability: "Analysis Error",
                        impact: "Unable to detect security issues",
                        prevention: "Ensure code is properly formatted",
                        testing: "Manual security testing required",
                        bestPractices: ["Check code manually"],
                        relatedIssues: ["Analysis system error"],
                        language: "All",
                        commonMistake: "Analysis system error",
                        securityImpact: "Unable to analyze"
                    }];
                case 'performance':
                    return [{
                        severity: "warning",
                        title: "Performance Analysis Failed",
                        description: "Unable to analyze performance issues",
                        lineStart: 1,
                        lineEnd: 1,
                        suggestion: "Please check your code for performance issues",
                        type: "performance",
                        bottleneck: "Analysis Error",
                        impact: "Unable to detect performance issues",
                        optimization: "Manual optimization required",
                        testing: "Manual performance testing required",
                        bestPractices: ["Check code manually"],
                        relatedIssues: ["Analysis system error"],
                        language: "All",
                        performanceImpact: "Unable to analyze",
                        optimizationPotential: "Unable to analyze"
                    }];
                default:
                    return [];
            }
        }

        function createBugCard(title, bugs) {
            const card = document.createElement('div');
            card.className = 'debug-card';
            card.innerHTML = `
                <div class="card-header">
                    <h3>${title}</h3>
                    <div class="score ${bugs.length > 5 ? 'error' : bugs.length > 2 ? 'warning' : ''}">${bugs.length}</div>
                </div>
                <div class="card-content">
                    ${bugs.map(bug => `
                        <div class="bug-item" data-start="${bug.lineStart}" data-end="${bug.lineEnd}">
                            <div class="bug-severity ${bug.severity}">${getSeverityIcon(bug.severity)}</div>
                            <div class="bug-content">
                                <div class="bug-title">${bug.title}</div>
                                <div class="bug-description">${bug.description}</div>
                                ${bug.scenario ? `<div class="bug-scenario">Scenario: ${bug.scenario}</div>` : ''}
                                ${bug.executionPath ? `<div class="bug-execution-path">Execution Path: ${bug.executionPath}</div>` : ''}
                                ${bug.potentialIssues ? `
                                    <div class="bug-potential-issues">
                                        <div class="bug-potential-issues-title">Potential Issues:</div>
                                        <ul>
                                            ${bug.potentialIssues.map(issue => `<li>${issue}</li>`).join('')}
                                        </ul>
                                    </div>
                                ` : ''}
                                <div class="bug-location">Lines ${bug.lineStart}-${bug.lineEnd}</div>
                                <div class="bug-suggestion">
                                    <div class="bug-suggestion-title">Suggested Fix:</div>
                                    <pre><code>${bug.suggestion}</code></pre>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;

            // Add click handlers for bug items
            card.querySelectorAll('.bug-item').forEach(item => {
                item.addEventListener('click', () => {
                    const start = parseInt(item.dataset.start);
                    const end = parseInt(item.dataset.end);
                    highlightCodeLines(start, end);
                });
            });

            return card;
        }

        function getSeverityIcon(severity) {
            const icons = {
                'critical': '!',
                'warning': 'âš ',
                'info': 'i'
            };
            return icons[severity] || '?';
        }

        // Add file system synchronization
        let fileWatcher = null;
        let currentDirectory = '';
        let isFileModified = false;
        let lastSavedContent = '';

        async function initializeFileSystem() {
            try {
                // Get the current directory from the server
                const response = await fetch('http://localhost:3000/api/files/current-directory');
                if (!response.ok) {
                    throw new Error('Failed to get current directory');
                }
                const data = await response.json();
                currentDirectory = data.directory;
                
                // Initialize file watcher
                initializeFileWatcher();
                
                // Initial file scan
                scanDirectory(currentDirectory);

                // Set up editor change listener
                if (window.editor) {
                    window.editor.onDidChangeModelContent(() => {
                        handleEditorChange();
                    });
                }
            } catch (error) {
                console.error('Failed to initialize file system:', error);
            }
        }

        function handleEditorChange() {
            if (!window.editor || !window.editor.getModel()) return;
            
            const model = window.editor.getModel();
            const path = model.uri.path;
            const currentContent = model.getValue();
            
            // Only save if content has actually changed
            if (currentContent !== lastSavedContent) {
                saveFileToLocal(path, currentContent);
                lastSavedContent = currentContent;
            }
        }

        async function saveFileToLocal(path, content) {
            try {
                // First, check if the file has been modified externally
                const checkResponse = await fetch(`http://localhost:3000/api/files/check?path=${encodeURIComponent(path)}`);
                if (!checkResponse.ok) {
                    throw new Error('Failed to check file status');
                }
                const checkData = await checkResponse.json();
                
                // If file has been modified externally, show warning
                if (checkData.modified) {
                    if (!confirm('File has been modified externally. Do you want to save your changes?')) {
                        return;
                    }
                }

                const response = await fetch('http://localhost:3000/api/files/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        path: path,
                        content: content
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to save file');
                }

                // Notify server about the change
                notifyFileChange(path);

                // Update status bar
                updateStatusBar('File saved');
            } catch (error) {
                console.error('Error saving file:', error);
                updateStatusBar('Error saving file');
                throw error;
            }
        }

        function notifyFileChange(path) {
            if (fileWatcher && fileWatcher.readyState === WebSocket.OPEN) {
                fileWatcher.send(JSON.stringify({
                    type: 'modify',
                    path: path,
                    content: window.editor.getModel().getValue()
                }));
            }
        }

        function initializeFileWatcher() {
            // Set up WebSocket connection for file system updates
            fileWatcher = new WebSocket('ws://localhost:3000/ws');
            
            fileWatcher.onmessage = (event) => {
                const update = JSON.parse(event.data);
                handleFileSystemUpdate(update);
            };

            fileWatcher.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatusBar('Connection error');
            };

            fileWatcher.onclose = () => {
                // Attempt to reconnect after a delay
                setTimeout(initializeFileWatcher, 5000);
            };
        }

        function handleFileSystemUpdate(update) {
            switch (update.type) {
                case 'create':
                    addFileToExplorer(update.path, update.isDirectory);
                    break;
                case 'delete':
                    removeFileFromExplorer(update.path);
                    break;
                case 'modify':
                    updateFileInExplorer(update.path, update.content);
                    break;
                case 'rename':
                    renameFileInExplorer(update.oldPath, update.newPath);
                    break;
            }
        }

        function updateFileInExplorer(path, content) {
            // If the file is currently open in the editor, update it
            if (window.editor && window.editor.getModel()) {
                const currentPath = window.editor.getModel().uri.path;
                if (currentPath === path) {
                    // Update the model's content
                    window.editor.getModel().setValue(content);
                    // Update last saved content
                    lastSavedContent = content;
                }
            }
        }

        async function openFile(path) {
            try {
                const response = await fetch(`http://localhost:3000/api/files/read?path=${encodeURIComponent(path)}`);
                if (!response.ok) {
                    throw new Error('Failed to read file');
                }
                const data = await response.json();
                
                // Create or update editor model
                const uri = monaco.Uri.file(path);
                let model = monaco.editor.getModel(uri);
                
                if (!model) {
                    model = monaco.editor.createModel(data.content, undefined, uri);
                } else {
                    model.setValue(data.content);
                }
                
                // Set the model as the editor's model
                window.editor.setModel(model);
                
                // Update last saved content
                lastSavedContent = data.content;
                
                // Update editor tabs
                updateEditorTabs(path);
                
                // Update status bar
                updateStatusBar('File opened');
            } catch (error) {
                console.error('Error opening file:', error);
                updateStatusBar('Error opening file');
            }
        }

        function updateEditorTabs(path) {
            const tabsContainer = document.getElementById('editor-tabs');
            const fileName = path.split('/').pop();
            
            // Check if tab already exists
            let tab = document.querySelector(`.editor-tab[data-path="${path}"]`);
            
            if (!tab) {
                // Create new tab
                tab = document.createElement('div');
                tab.className = 'editor-tab';
                tab.dataset.path = path;
                
                const name = document.createElement('span');
                name.textContent = fileName;
                
                const closeButton = document.createElement('span');
                closeButton.className = 'close-button';
                closeButton.innerHTML = 'Ã—';
                closeButton.onclick = (e) => {
                    e.stopPropagation();
                    closeFile(path);
                };
                
                tab.appendChild(name);
                tab.appendChild(closeButton);
                tabsContainer.appendChild(tab);
            }
            
            // Update active state
            document.querySelectorAll('.editor-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
        }

        function closeFile(path) {
            const model = monaco.editor.getModel(monaco.Uri.file(path));
            if (model) {
                model.dispose();
            }
            
            // Remove tab
            const tab = document.querySelector(`.editor-tab[data-path="${path}"]`);
            if (tab) {
                tab.remove();
            }
            
            // Clear editor if no more files are open
            if (document.querySelectorAll('.editor-tab').length === 0) {
                window.editor.setModel(null);
            }
        }

        // Initialize file system when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeFileSystem();
        });

        // Add these variables at the top of your script
        let debugTimeout = null;
        let lastDebugContent = '';
        let debugAssistanceEnabled = false;
        let debugOutputPanel = null;

        // Add these functions to your script
        function toggleDebugAssistance() {
            debugAssistanceEnabled = document.getElementById('debug-toggle').checked;
            if (debugAssistanceEnabled) {
                showDebugOutput();
                addDebugMessage('info', 'Real-time debugging assistance enabled');
            } else {
                hideDebugOutput();
                addDebugMessage('info', 'Real-time debugging assistance disabled');
            }
        }

        function toggleDebugOutput() {
            const panel = document.getElementById('debug-output-panel');
            if (panel.classList.contains('active')) {
                panel.classList.remove('active');
            } else {
                panel.classList.add('active');
            }
        }

        function showDebugOutput() {
            const panel = document.getElementById('debug-output-panel');
            panel.classList.add('active');
        }

        function hideDebugOutput() {
            const panel = document.getElementById('debug-output-panel');
            panel.classList.remove('active');
        }

        function addDebugMessage(type, message, lineNumber = null, suggestion = null) {
            const content = document.getElementById('debug-output-content');
            const messageDiv = document.createElement('div');
            messageDiv.className = `debug-message ${type}`;
            
            let messageHtml = '';
            if (lineNumber) {
                messageHtml += `<span class="line-number">Line ${lineNumber}:</span>`;
            }
            messageHtml += `<span class="message-content">${message}</span>`;
            
            if (suggestion) {
                messageHtml += `<div class="suggestion">${suggestion}</div>`;
            }
            
            messageDiv.innerHTML = messageHtml;
            content.appendChild(messageDiv);
            content.scrollTop = content.scrollHeight;
        }

        // Modify the editor initialization to include real-time debugging
        function initializeEditor() {
            // ... existing editor initialization code ...

            // Add content change listener for real-time debugging
            window.editor.onDidChangeModelContent(() => {
                if (!debugAssistanceEnabled) return;

                // Clear previous timeout
                if (debugTimeout) {
                    clearTimeout(debugTimeout);
                }

                // Get current content
                const currentContent = window.editor.getModel().getValue();
                
                // Only analyze if content has changed significantly
                if (currentContent !== lastDebugContent) {
                    // Set new timeout for analysis
                    debugTimeout = setTimeout(() => {
                        analyzeCurrentCode();
                    }, 1000); // Wait 1 second after typing stops
                }
                
                lastDebugContent = currentContent;
            });
        }

        async function analyzeCurrentCode() {
            if (!window.editor || !window.editor.getModel()) return;

            const currentContent = window.editor.getModel().getValue();
            const currentLanguage = window.editor.getModel().getLanguageId();
            
            try {
                // Quick syntax check
                const response = await fetch('http://localhost:3000/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: `Quick syntax check for ${currentLanguage} code. Return ONLY a JSON array in this format:
                        [
                            {
                                "severity": "critical/warning/info",
                                "title": "string",
                                "description": "string",
                                "lineStart": number,
                                "lineEnd": number,
                                "suggestion": "string"
                            }
                        ]`,
                        currentFileContent: currentContent
                    })
                });

                if (!response.ok) throw new Error('Syntax check failed');
                const data = await response.json();
                const issues = JSON.parse(data.response);

                // Clear previous messages
                const content = document.getElementById('debug-output-content');
                content.innerHTML = '';

                // Add new messages
                issues.forEach(issue => {
                    addDebugMessage(
                        issue.severity,
                        `${issue.title}: ${issue.description}`,
                        issue.lineStart,
                        issue.suggestion
                    );
                });

            } catch (error) {
                console.error('Real-time analysis error:', error);
                addDebugMessage('error', `Analysis error: ${error.message}`);
            }
        }

        // Update the copy functionality
        function copyCode(button, code) {
            // Decode HTML entities in the code
            const decodedCode = code
                .replace(/&lt;/g, '<')
                .replace(/&gt;/g, '>')
                .replace(/&amp;/g, '&')
                .replace(/&quot;/g, '"')
                .replace(/&#039;/g, "'");

            // Create a temporary textarea element
            const textarea = document.createElement('textarea');
            textarea.value = decodedCode;
            document.body.appendChild(textarea);
            textarea.select();

            try {
                // Try using the modern Clipboard API
                navigator.clipboard.writeText(decodedCode).then(() => {
                    // Visual feedback
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    
                    // Reset after 2 seconds
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                }).catch(() => {
                    // Fallback to execCommand if Clipboard API fails
                    document.execCommand('copy');
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                });
            } catch (err) {
                console.error('Failed to copy code:', err);
                button.textContent = 'Failed';
                setTimeout(() => {
                    button.textContent = 'Copy';
                }, 2000);
            } finally {
                // Clean up
                document.body.removeChild(textarea);
            }
        }

        // Update the formatChatMessage function to use Prism.js
        function formatChatMessage(message) {
            // Replace code blocks with formatted versions that include copy buttons
            return message.replace(/```(\w+)?\n([\s\S]*?)```/g, (match, lang, code) => {
                const trimmedCode = code.trim();
                // Escape special characters in the code
                const escapedCode = trimmedCode
                    .replace(/\\/g, '\\\\')
                    .replace(/`/g, '\\`')
                    .replace(/\$/g, '\\$');
                
                // Map language names to Prism.js language names
                const languageMap = {
                    'js': 'javascript',
                    'py': 'python',
                    'sh': 'bash',
                    'md': 'markdown'
                };
                
                const prismLang = languageMap[lang] || lang || 'plaintext';
                
                return `
                    <div class="code-block-container">
                        <button class="copy-button" onclick="copyCode(this, \`${escapedCode}\`)">Copy</button>
                        <pre class="line-numbers language-${prismLang}"><code class="language-${prismLang}">${trimmedCode}</code></pre>
                    </div>
                `;
            });
        }

        // Update the addMessage function to highlight code after adding to DOM
        function addMessage(content, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isUser ? 'user' : 'assistant'}`;
            messageDiv.innerHTML = formatChatMessage(content);
            chatMessages.appendChild(messageDiv);
            
            // Highlight code blocks after adding to DOM
            messageDiv.querySelectorAll('pre code').forEach((block) => {
                Prism.highlightElement(block);
            });
            
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Add code execution functionality
        async function runCode() {
            const editor = monaco.editor.getEditors()[0];
            if (!editor) {
                addTerminalMessage('No code to run. Please open a file first.', 'error');
                return;
            }

            const code = editor.getValue();
            if (!code.trim()) {
                addTerminalMessage('No code to run', 'error');
                return;
            }

            // Open terminal panel
            const terminalPanel = document.getElementById('terminal-panel');
            terminalPanel.classList.add('active');
            
            // Update activity bar icon
            document.querySelectorAll('.activity-bar-icon').forEach(icon => {
                icon.classList.remove('active');
            });
            document.querySelector('.activity-bar-icon[onclick="togglePanel(\'terminal\')"]').classList.add('active');

            const language = editor.getModel().getLanguageId();
            const runButton = document.getElementById('run-button');
            const runText = runButton.querySelector('.run-text');
            
            try {
                // Disable run button and show loading state
                runButton.disabled = true;
                runText.textContent = 'Running...';
                addTerminalMessage(`Running ${language} code...`, 'info');

                const response = await fetch('http://localhost:3000/run', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ language, code })
                });

                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to execute code');
                }

                // Show the actual output in the terminal
                if (data.output) {
                    // Split the output into lines and display each line
                    const outputLines = data.output.split('\n');
                    outputLines.forEach(line => {
                        if (line.trim()) {
                            addTerminalMessage(line, data.error ? 'error' : 'success');
                        }
                    });
                } else {
                    addTerminalMessage('No output received', 'info');
                }

            } catch (error) {
                console.error('Code execution error:', error);
                addTerminalMessage(error.message || 'Failed to execute code', 'error');
            } finally {
                // Re-enable run button and restore text
                runButton.disabled = false;
                runText.textContent = 'Run';
            }
        }

        // Add terminal message function
        function addTerminalMessage(message, type = 'info') {
            const terminalContent = document.getElementById('terminal-content');
            const messageDiv = document.createElement('div');
            messageDiv.className = `terminal-message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `<span class="terminal-timestamp">[${timestamp}]</span> ${message}`;
            
            terminalContent.appendChild(messageDiv);
            terminalContent.scrollTop = terminalContent.scrollHeight;
        }

        // Add playground functionality
        let playgroundEditor = null;

        function togglePlaygroundPanel() {
            const playgroundPanel = document.getElementById('playground-panel');
            playgroundPanel.style.display = 'none';
            // Show the editor container
            document.querySelector('.editor-container').style.display = 'flex';
            // Remove active class from playground button
            document.querySelector('.activity-bar-icon[onclick="togglePanel(\'playground\')"]').classList.remove('active');
        }

        function updatePlaygroundLanguage() {
            if (!playgroundEditor) return;
            const language = document.getElementById('playground-language').value;
            monaco.editor.setModelLanguage(playgroundEditor.getModel(), language);
        }

        function initializePlayground() {
            const container = document.getElementById('playground-editor');
            playgroundEditor = monaco.editor.create(container, {
                value: '// Write your code here\n',
                language: 'python',
                theme: 'vs-dark',
                automaticLayout: true,
                minimap: { enabled: false },
                scrollBeyondLastLine: false,
                fontSize: 14,
                lineNumbers: 'on',
                roundedSelection: false,
                scrollbar: {
                    vertical: 'visible',
                    horizontal: 'visible'
                }
            });
        }

        async function runPlaygroundCode() {
            if (!playgroundEditor) return;

            const code = playgroundEditor.getValue();
            const language = document.getElementById('playground-language').value;
            const runButton = document.getElementById('playground-run');
            const runText = runButton.querySelector('.run-text');
            const output = document.getElementById('playground-output');

            try {
                // Disable run button and show loading state
                runButton.disabled = true;
                runText.textContent = 'Running...';
                addPlaygroundMessage(`Running ${language} code...`, 'info');

                const response = await fetch('http://localhost:3000/run', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ language, code })
                });

                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to execute code');
                }

                // Show the actual output in the terminal
                if (data.output) {
                    // Split the output into lines and display each line
                    const outputLines = data.output.split('\n');
                    outputLines.forEach(line => {
                        if (line.trim()) {
                            addPlaygroundMessage(line, data.error ? 'error' : 'success');
                        }
                    });
                } else {
                    addPlaygroundMessage('No output received', 'info');
                }

            } catch (error) {
                console.error('Code execution error:', error);
                addPlaygroundMessage(error.message || 'Failed to execute code', 'error');
            } finally {
                // Re-enable run button and restore text
                runButton.disabled = false;
                runText.textContent = 'Run';
            }
        }

        function addPlaygroundMessage(message, type = 'info') {
            const output = document.getElementById('playground-output');
            const messageDiv = document.createElement('div');
            messageDiv.className = `terminal-message ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            messageDiv.innerHTML = `<span class="terminal-timestamp">[${timestamp}]</span> ${message}`;
            
            output.appendChild(messageDiv);
            output.scrollTop = output.scrollHeight;
        }

        // Initialize playground when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            initializeFileSystem();
            initializePlayground();
        });

        // Add this new function to handle chat panel closing
        function toggleChatPanel() {
            const chatPanel = document.getElementById('chat-panel');
            chatPanel.style.display = 'none';
            // Remove active class from chat button
            document.querySelector('.activity-bar-icon[onclick="togglePanel(\'chat\')"]').classList.remove('active');
        }
    </script>
    <script src="workspace.js"></script>
</body>
</html>

